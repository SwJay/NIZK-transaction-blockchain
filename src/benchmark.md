# 测试文档
## 说明
- demo基于[An Efficient NIZK Scheme for Privacy-Preserving](http://www.juzix.net/en/resource/files/NIZK.pdf)，使用C++实现。
- 第三方库：*pbc*，用于实现双线性对；*nacl*，用于实现预言机。
- 实现细节：
  - 随机预言机：将 commitment 中所有属于$G1$的元相乘，与$g2$进行配对得到$Gt$的元，再和commitment中所有属于$Gt$的元相乘。对最终得到的$Gt$的元进行*sha512*的哈希计算，用这个哈希值生成环上的challenge。
  - 优化——余额验证：由于论文中使用基于双线性对的加密，得到用户余额需要计算离散对数问题(*dlog*)。在实现时，使用*pbc*提供的函数暴力求解，求解的时间复杂度为$O(n)$，仅在明文空间足够小的时候有实用性。为提升解密的效率，引入余额验证的方法：在钱包本地存储账户余额的明文，当用户转账生成证明需要提供账户余额时，先对明文进行验证，验证通过则直接使用明文，只有验证未通过时才求解*dlog*。将余额的同步操作安排到空闲时自动进行，交易执行时无需求解*dlog*，可显著提升交易的效率。




## 交易体与证明
### 交易体结构
```
{
    "transactions": [
        {
            "transaction_id": "",
            "signature": "",
            "actions": [
            	"account": { 
            		"public_key1": "",
            		"public_key2": ""
            	},
            	"name": "transaction",
            	"data": {
            		"to": {
            			"public_key1": "",
            			"public_key2": ""
            		},
            		"quantity_from": {
            			"verify_key1": "",
            			"verify_key2": "",
            			"cipher_quantity": ""
            		},
            		"quantity_to": { 
            			"verify_key1": "",
            			"verify_key2": "",
            			"cipher_quantity": ""
            		},
            		"proof": {
            			"commitment": { 
            				"R1": "",
            				"R2": "",
            				"_R1": "",
            				"_R2": "",
            				"V": {
            					"V0": "",
            					"V1": "",
            					"V2": ""
            				},
            				"_V": {
            					"_V0": "",
            					"_V1": "",
            					"_V2": ""
            				},
            				"D1": "",
            				"D2": "",
            				"a": {
            					"a0": "",
            					"a1": "",
            					"a2": ""
            				},
            				"_a": {
            					"_a0": "",
            					"_a1": "",
            					"_a2": ""
            				},
            				"alpha": ""
            			},
            			"challenge": "",
            			"response": { 
            				"z1": "",
            				"z2": "",
            				"zv": {
            					"zv0": "",
            					"zv1": "",
            					"zv2": "",
            				},
            				"_zv": {
            					"_zv0": "",
            					"_zv1": "",
            					"_zv2": "",
            				},
            				"zt": {
            					"zt0": "",
            					"zt1": "",
            					"zt2": "",
            				},
            				"_zt": {
            					"_zt0": "",
            					"_zt1": "",
            					"_zt2": "",
            				},
            				"zl": "",
            				"zk": "",
            				"_z": ""
            			}
            		}
            		"memo": ""
            	},
            	"hex_data": ""
            ]
        }
    ]
}
```
- 与传统交易体不同的地方有三：

1. 账户的地址是一对公钥；
2. 交易金额是两份密文，分别由交易双方的公钥生成sk进行加密，且每一份附带了一对vk；
3. 每笔交易需提供一个证明

### 交易体大小
- 交易体大小：4354 Bytes
- 证明大小：2792 Bytes



## 测试
### 测试方案：
​	进行500组转账金额，分别记录总时间、证明生成时间、验证时间。500组转账测试中，各组账户余额构成等差数列(10,000 ~ 5,000,000， 差值为10,000)，转账金额为$0～2^{30}-1$在正态分布下的随机数模帐户余额（保证验证一定通过）。

 ### 测试环境：

| 环境 | 配置     |
| ---- | -------- |
| 处理器 | Intel® Core™ i5-6300HQ CPU @ 2.30GHz × 4 |
|系统 | ubuntu 16.04 LTS |


### 测试结果：

| 500组总时间(ms) | proof | verify |
| - | - | - |
| 优化前 | 7906977.478 | 15715.256 |
| 优化后 | 20219.227 | 15564.833 |

​	可以看到在做了优化后，进行交易时生成证明的时间大大缩短，由$O(n)$直接变成$O(1)$，具备实用性。

### 已优化单笔交易时间：

| 测试项   | transaction | proof     | verify    |
| -------- | ----------- | --------- | --------- |
| 时间(ms) | 71.42993    | 40.438454 | 31.129666 |

*上表中 transaction 与 proof, verify为独立测试*

- 一秒内可生成交易次数：14次